// Package diag provides diagnostic tools for chess engines.
package diag

import (
	"bufio"
	"github.com/andrewbackes/chess"
	"os"
	"strconv"
	"strings"
)

/*******************************************************************************

	Divide:

*******************************************************************************/

// Divide is a diagnostic tool used for figuring out which moves are not
// being generated by an engine. It returns a list of moves and a count
// of how many moves are in that tree of moves with the given depth.
func Divide(G *game.Game, depth int) map[game.Move]uint64 {
	div := make(map[game.Move]uint64)
	//fmt.Println("Depth", depth)
	var nodes, moveCount uint64
	ml := G.LegalMoves()
	toMove := G.ActiveColor()
	for mv := range ml {
		temp := *G
		temp.MakeMove(mv)

		if temp.Check(toMove) == false {
			//Count it for mate:
			moveCount++
			n, _, _, _, _, _, _ := perft(&temp, depth-1)
			div[mv] = n
			nodes += n
		}
	}
	return div
}

/*******************************************************************************

	Perft:

*******************************************************************************/

// Perft retuns the number of possible moves from the given board position and game.Game
// state at the given depth.
func Perft(g *game.Game, depth int) uint64 {
	n, _, _, _, _, _, _ := perft(g, depth)
	return n
}

func perft(G *game.Game, depth int) (nodes, checks, castles, mates, captures, promotions, enpassant uint64) {
	var moveCount uint64

	if depth == 0 {
		return 1, 0, 0, 0, 0, 0, 0
	}

	toMove := G.ActiveColor()
	notToMove := []game.Color{game.Black, game.White}[toMove]

	isChecked := G.Check(toMove)
	ml := G.LegalMoves()

	for mv := range ml {
		temp := *G
		temp.QuickMove(mv)
		if temp.Check(toMove) == false {
			//Count it for mate:
			moveCount++
			n, c, cstl, m, cap, p, enp := perft(&temp, depth-1)
			nodes += n
			checks += c + toInt(temp.Check(notToMove))
			castles += cstl + toInt(isCastle(G, mv))
			mates += m
			captures += cap + toInt(isCapture(G, mv))
			promotions += p + toInt(isPromotion(G, mv))
			enpassant += enp + toInt(isEnPassant(G, mv))
		}
	}
	if moveCount == 0 && isChecked {
		mates++
	}
	return nodes, checks, castles, mates, captures, promotions, enpassant
}

/*******************************************************************************

	Helpers:

*******************************************************************************/

func isCastle(G *game.Game, m game.Move) bool {
	from, _ := game.SquaresOf(m)
	p := G.Board().OnSquare(from)
	if p.Type == game.King {
		if (m == "e1g1") || (m == "e1c1") || (m == "e8g8") || (m == "e8c8") {
			return true
		}
	}
	return false
}

func isCapture(G *game.Game, m game.Move) bool {
	_, to := game.SquaresOf(m)
	capPiece := G.Board().OnSquare(to)
	return (capPiece.Type != game.None)
}

func isPromotion(G *game.Game, m game.Move) bool {
	// TODO: will not work when more notation is added
	return (len(m) > 4)
}

func isEnPassant(G *game.Game, m game.Move) bool {
	if G.EnPassant() == nil {
		return false
	}
	from, to := game.SquaresOf(m)
	p := G.Board().OnSquare(from)
	return (p.Type == game.Pawn) && (to == *G.EnPassant()) && ((from-to)%8 != 0)
}

func toInt(b bool) uint64 {
	if b == true {
		return 1
	}
	return 0
}

type epdTest struct {
	fen   string
	nodes []uint64
}

func loadPerftSuite(filename string) ([]epdTest, error) {

	f, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	scanner := bufio.NewScanner(f)

	var test []epdTest
	for scanner.Scan() {
		line := scanner.Text()
		words := strings.Split(line, ";")

		var newTest epdTest
		newTest.fen = words[0]
		newTest.nodes = append(newTest.nodes, 1) // depth 0 = 1 node

		for i := 1; i < len(words); i++ {
			n, _ := strconv.ParseUint(strings.Split(words[i], " ")[1], 10, 0)
			newTest.nodes = append(newTest.nodes, n)
		}

		test = append(test, newTest)
	}
	f.Close()

	return test, err
}
